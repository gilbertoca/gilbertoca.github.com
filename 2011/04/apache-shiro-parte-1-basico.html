<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
    Vivendo e Aprendendo ...
        - Apache Shiro Parte 1 - básico
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Author">
    <meta name="description" content="Static blog generated with JBake">

    <!-- Style -->
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootswatch/3.1.1/spacelab/bootstrap.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
    <link rel="stylesheet" href="/css/base.css">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
    <![endif]-->

    <!-- Fav icon -->
    <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/img/favicon.ico" type="image/x-icon">
  </head>
  <body>      
    <nav class="navbar navbar-default navbar-fixed-top " role="navigation">
      <div class="container">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">Vivendo e Aprendendo ...</a>
        </div>
        
        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
          <ul class="nav navbar-nav">
            <li><a href="/pages/about.html">About me</a></li>
            <li><a href="/pages/contact.html">Contact</a></li>
          </ul>
        
        <!-- Right navigation -->
        <ul class="nav navbar-nav navbar-right">
              <li><a href="http://twitter.com/gilberto_gca" title="Twitter"><i class="fa fa-twitter-square"></i></a></li>
              <li><a href="https://github.com/gilbertoca" title="Github"><i class="fa fa-github-square"></i></a></li>
          <li><a href="/archive.html"><i class="fa fa-list"></i> Archive</a></li>
          <li><a href="/feed.xml" title="Rss"><i class="fa fa-rss"></i> Feed</a></li>
        </ul>
        <!-- Right navigation end -->

      </div><!-- /.navbar-collapse -->
      </div><!-- /.container-fluid -->
    </nav><!-- /.navbar -->

    <!-- Begin page content -->
    <div class="container">
      
      <div class="row">
        <div class="col-md-12">
          <article>
            <div class="page-header"><h1>Apache Shiro Parte 1 - básico</h1>
              <ol class="breadcrumb tagsbar">
                <li><a href="/tags/protecao.html">protecao</a></li>
                <li><a href="/tags/application-server.html">application-server</a></li>
                <li><a href="/tags/java.html">java</a></li>
                <li><a href="/tags/maven.html">maven</a></li>
                <li><a href="/tags/traducoes-2.html">traducoes-2</a></li>
                <li><a href="/tags/apache-shiro.html">apache-shiro</a></li>
                <li><a href="/tags/autenticacao.html">autenticacao</a></li>
                <li><a href="/tags/autorizacao.html">autorizacao</a></li>
                <li><a href="/tags/recursos-de-seguranca.html">recursos-de-seguranca</a></li>
              </ol>
            </div>
          <p class="post-meta">
            <i class="fa fa-calendar"></i>&nbsp;07 Abril 2011&nbsp;&nbsp;
            <i class="fa fa-user"></i>&nbsp;Author&nbsp;&nbsp;
          </p>
              <p>
<strong><p>
<br />Este post é uma tradução livre do artigo "<a href="http://meri-stuff.blogspot.com/2011/03/apache-shiro-part-1-basics.html" target="_blank"> Apache Shiro Part 1 - Basics </a>", publicado por Meri em 27 de março 2011
<br /></p></strong>
<br /><strong>ATUALIZAÇÃO: duas novas seções adicionadas - tratamento de erros e hashing de senhas.</strong>
<br /><p>
<br /><A href="http://shiro.apache.org/index.html" target="_blank"> Apache Shiro</A>, inicialmente chamado JSecurity, é um framework de segurança desenvolvido em java. Foi aceito e tornou-se um projeto Apache de nível superior em 2010. Tem como objetivo ser poderoso e fácil de usar.
<br /></p>
<br /><p>
<br />O projeto está em constante desenvolvimento e com listas de e-mails ativas para usuários e desenvolvedores. Áreas mais importantes estão <a href="http://shiro.apache.org/documentation.html" target="_blank"> documentadas em sua página web</a>. No entanto, existem algumas lacunas na documentação. Não é possível aprender a usar o máximo dos recursos do Shiro somente com a documentação. Felizmente, o código é bem documentado e onde o testei, ela foi de fácil leitura.
<br /></p>
<br /><p>
<br />Principais recursos do projeto Shiro são:
<br /><UL>
<br /><LI>autenticação,</LI>
<br /><LI>autorização,</LI>
<br /><LI>criptografia,</LI>
<br /><LI>gerenciamento de sessão.</LI>
<br /></UL>
<br /></p>
<br /><p>
<br />Neste artigo tentaremos demonstrar vários recursos do Shiro. Vamos começar com uma simples aplicação sem segurança e então adicionaremos recursos de segurança. Todo código está disponível no projeto <A href="https://github.com/SomMeri/SimpleShiroSecuredApplication" target="_blank"> SimpleShiroSecuredApplication</A>  hospedado no <a href="https://github.com/" target="_blank"> Github</a>.
<br /></p>
<br /><H4>Aplicação sem Segurança</H4>
<br /><p>
<br />O código da aplicação sem segurança está localizado no ramo(branch) <A href="https://github.com/SomMeri/SimpleShiroSecuredApplication/tree/unsecured_application" target="_blank"> unsecured_application</A>. 
<br />A aplicação representa um sistema interno para uma companhia fictícia. A companhia tem quatro departamentos:
<br /><UL>
<br /><LI>administradores(administrators),</LI>
<br /><LI>reparadores(repairmen),</LI>
<br /><LI>cientistas(scientists),</LI>
<br /><LI>vendedores(sales).</LI>
<br /></UL>
<br /></p>
<br /><p>
<br />Cada departamento tem sua própria página. Cada página contém botões que serão usados por usuários em sua atividade. Quando o usuário pressiona o botão, o trabalho é realizado. Por exemplo, qualquer reparador pode acessar a página reparadores(repairmen) e pressionar o botão "Reparar Refrigerador(Repair Refrigerator)". O botão repara refrigerador e mostra mensagem de sucesso.
<br /></p>
<br /><p>
<br />Cada usuário tem sua própria página de gerenciamento de conta. Esta página de gerenciamento contém informações privadas do usuário. Como a aplicação sem segurança não tem usuários ainda, a página de gerenciamento de conta não faz nada. Adicionalmente, há uma página que contém todas funções da aplicação. Tudo que alguém pode fazer é possível ser feito nesta página.
<br /></p>
<br /><p>
<br />Qualquer pessoa pode fazer qualquer coisa e ver todas as páginas. A aplicação exemplo é executada na classe de teste <A href="https://github.com/SomMeri/SimpleShiroSecuredApplication/blob/unsecured_application/src/test/java/org/meri/simpleshirosecuredapplication/RunWaitTest.java" target="_blank"> RunWaitTest</A>. Não é uma boa prática usar teste de unidade desta forma, mas isso não é importante agora. Se você executar a classe a aplicação estará disponível no endereço (url) http://localhost:9180/simpleshirosecuredapplication/.
<br /></p>
<br /><H4>Adicionando Autenticação</H4>
<br /><p>
<br />Primeiro, temos que verificar a identidade do usuário. A mais fácil e padronizada forma de autenticação é feita por senha e nome usuário. Usuário preenche o seu nome de usuário e senha e o sistema verifica se os valores fornecidos combinam com alguma conta de usuário.
<br /></p>
<br /><p>
<br />Para aplicações mais simples, é suficiente armazenar nome e senha de usuários em arquivos de texto puro. Em um cenário mais realista, o nome e senha são armazenados em um mecanismo de persistente or a verificação é feita por outro sistema como ldap ou active directory. Shiro suporta todos os métodos de autenticação mencionados. Se os recursos de autenticação pré-existentes não são suficientes, é possível estender o framework com sua própria implementação de verificação. 
<br /></p>
<br /><p>
<br />Neste capítulo, iremos adicionar autenticação baseada em nome de usuário e senha na aplicação. Nome de usuário e senha serão armazenados no arquivo de inicialização do Shiro, o qual é texto e estático.
<br /></p>
<br /><p>
<br /><B>Novos requisitos:</B> 
<br />É possível a entrada e saída de usuários(log in/out). A aplicação será acessível somente para usuários registrados. Usuário com autenticação sem erros é redirecionado para sua própria página de gerenciamento de conta. Todas as páginas e funções da aplicação serão acessíveis para qualquer usuário autenticado.
<br />Passos necessários:
<br /><UL>
<br /><LI>adicionar Apache Shiro,</LI>
<br /><LI>criar página de autenticação(log in),</LI>
<br /><LI>configurar usuários e senhas,</LI>
<br /><LI>criar página de saída(log out).</LI>
<br /></UL>
<br /></p>
<br /><H5>Adicionar Apache Shiro</H5>
<br /><p>
<br />Shiro é integrado à aplicação web através de <a href="http://download.oracle.com/javaee/5/api/javax/servlet/Filter.html" target="_blank"> filtros servlet</a>. Um filtro intercepta requisições e respostas antes do servlet e executa todas as tarefas necessárias (como a identificação do usuário atualmente autenticado, anexar o usuário ao thread corrente, ...). Filtros Shiro pré-definidos fornecem recursos de segurança básicos, como:
<br /><UL>
<br /><LI>força a autenticação do usuário(log in),</LI>
<br /><LI>força ssl,</LI>
<br /><LI>verificação dos direitos de acesso à página.</LI>
<br /></UL>
<br /></p>
<br /><p>
<br />Se você quiser aprender mais sobre filtros Shiro pré-definidos, um bom lugar para começar é a enumeração <A href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/mgt/DefaultFilter.html" target="_blank"> DefaultFilter</A>. Ela lista todos os filtros Shiro pré-definidos disponíveis. Se estes não forem suficientes para suas necessidades, você pode criar um personalizado.
<br /></p>
<br /><p>
<br />Usaremos o filtro altamente configurável <A href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/servlet/IniShiroFilter.html" target="_blank"> IniShiroFilter</A>. Ele lê a configuração Shiro a partir do arquivo ini e inicializa o framework de segurança. Ele não executa qualquer verificação de segurança. Verificação de segurança, autenticação de usuário, verificação de protocolo, etc. são todos transferidos(delegados) tanto para o filtro Shiro pré-definido quanto para o filtro personalizado(outra implementação). O filtro IniShiroFilter apenas os inicializa.
<br /></p>
<br /><p>
<br />A configuração ini é descrita na <A href="http://shiro.apache.org/configuration.html" target="_blank"> documentação</A> e no <A href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/servlet/IniShiroFilter.html" target="_blank"> javadoc</A>. O arquivo de configuração ini tem quatro seções:
<br /><UL>
<br /><LI>Seção [main] contém a inicialização do Shiro. Filtros e objetos personalizados são configurados aqui. </LI>
<br /><LI>Seção [users] define usuários, senhas e perfis de usuário(roles). </LI>
<br /><LI>Seção [roles] associa perfis(roles) com permissões.</LI>
<br /><LI>Seção [urls] especifica direitos de acesso às páginas da aplicação (urls). É feito ligando filtro tanto pré-definido quanto personalizado às urls</LI>
<br /></UL>
<br /></p>
<br /><p>
<br />Adicione Apache Shiro como dependência ao arquivo pom.xml:
<br /><PRE lang="xml">
<br /><properties>
<br />    <shiro.version>1.1.0</shiro.version>
<br /></properties>
<br /><dependencies>
<br />    <dependency>
<br />        <groupId>org.apache.shiro</groupId>
<br />        <artifactId>shiro-core</artifactId>
<br />        <version>${shiro.version}</version>
<br />    </dependency>
<br />    <dependency>
<br />        <groupId>org.apache.shiro</groupId>
<br />        <artifactId>shiro-web</artifactId>
<br />        <version>${shiro.version}</version>
<br />    </dependency>
<br /></dependencies>
<br /></PRE>
<br /></p>
<br /><p>
<br />Crie o arquivo Shiro.ini e o coloque no classpath. Configure o arquivo web.xml para chamar o filtro IniShiroFilter antes de cada requisição:
<br />
<br /><PRE lang="xml">
<br /><filter>
<br />    <filter-name>ShiroFilter</filter-name>
<br />    <filter-class>org.apache.shiro.web.servlet.IniShiroFilter</filter-class>
<br />    <init-param>
<br />        <param-name>configPath</param-name>
<br />        <param-value>classpath:Shiro.ini</param-value>
<br />    </init-param>
<br /></filter>
<br /><filter-mapping>
<br />    <filter-name>ShiroFilter</filter-name>
<br />    <url-pattern>/*</url-pattern>
<br /></filter-mapping>
<br /></PRE>
<br /></p>
<br /><H5>Criar Página de Autenticação(Log in)</H5>
<br /><p>
<br />A página de autenticação é uma simples página html contendo um botão submissão, nome de usuário e senha. A funcionalidade de autenticação é tratada pelo filtro Shiro authc pré-definido. O filtro autch permite acesso à página (url) somente a usuários autenticados. Se o usuário não está autenticado, o filtro o redirecionará para a página de autenticação (log in).
<br /></p>
<br /><p>
<br />Crie a página login.jsp:
<br />
<br /><PRE lang="xml">
<br /><form name="loginform" action="" method="post">
<br />    <table align="left" border="0" cellspacing="0" cellpadding="3">
<br />        <tr>
<br />            <td>Username:</td>
<br />            <td><input type="text" name="user" maxlength="30"></td>
<br />        </tr>
<br />        <tr>
<br />            <td>Password:</td>
<br />            <td><input type="password" name="pass" maxlength="30"></td>
<br />        </tr>
<br />        <tr>
<br />            <td colspan="2" align="left"><input type="checkbox" name="remember"><font size="2">Remember Me</font></td>
<br />        </tr>
<br />        <tr>
<br />            <td colspan="2" align="right"><input type="submit" name="submit" value="Login"></td>
<br />        </tr>
<br />    </table>
<br /></form>
<br />
<br /></PRE>
<br /></p>
<br /><p>
<br />Habilite o filtro authc para todas as páginas da aplicação:
<br /><PRE lang="vim">
<br />[main] 
<br /># specify login page
<br />authc.loginUrl = /simpleshirosecuredapplication/account/login.jsp
<br />
<br /># name of request parameter with username; if not present filter assumes 'username'
<br />authc.usernameParam = user
<br /># name of request parameter with password; if not present filter assumes 'password'
<br />authc.passwordParam = pass
<br /># does the user wish to be remembered?; if not present filter assumes 'rememberMe'
<br />authc.rememberMeParam = remember
<br />
<br /># redirect after successful login
<br />authc.successUrl  = /simpleshirosecuredapplication/account/personalaccountpage.jsp
<br />
<br />[urls]
<br /># enable authc filter for all application pages
<br />/simpleshirosecuredapplication/**=authc
<br /></PRE>
<br /><B>Atualização:</B> Shiro automaticamente executa a equiparação(comparação) de caminho(path matching) relativa ao contexto. Como a aplicação SimpleShiroSecuredApplication não tem o caminho do contexto definido, caminhos completos no arquivo Shiro.ini são necessários. No entanto, se o contexto da aplicação fosse definido para /simpleshirosecuredapplication, então os caminhos poderiam ser relativos, por exemplo, /**=authc ou /account/personalaccountpage.jsp. 
<br /></p>
<br /><p>
<br />Como não é seguro enviar nome de usuário e senha pela rede, devemos forçar autenticações com o protocolo ssl. O filtro ssl faz exatamente isso. Ele tem um parâmetro opcional: número da porta ssl. Se o parâmetro porta(port) for omitido, ele usa a porta ssl pré-definida 443.
<br /></p>
<br /><p>
<br />Antes de configurar o protocolo ssl no Shiro, precisamos habilitá-lo no servidor web. Como fazer isso, depende do servidor web. Iremos demonstrar como habilitá-lo no <a href="http://jetty.codehaus.org/jetty/" target="_blank"> Jetty</a>. Primeiro, crie um keystore com o certificado auto assinado:
<br /><PRE lang="bash">
<br />keytool -genkey -keyalg RSA -alias jetty -keystore keystore -storepass secret -validity 360 -keysize 2048
<br /></PRE>
<br />Responda todas questões e no final pressione ENTER, assim o keystore senha e a chave senha serão o mesmo.
<br /></p>
<br /><p>
<br />Segundo, adicione o keystore ao projeto e configure <a href="http://jetty.codehaus.org/jetty/" target="_blank"> o servidor Jetty</a> para usar o protocolo ssl. O código java está disponível na classe<A href="https://github.com/SomMeri/SimpleShiroSecuredApplication/blob/static_authentication_and_authorization/src/test/java/org/meri/simpleshirosecuredapplication/test/AbstractContainerTest.java" target="_blank"> AbstractContainerTest</A>.
<br /></p>
<br /><p>
<br />Agora é possível configurar o filtro ssl no arquivo Shiro.ini:
<br /><PRE lang="vim">
<br />[urls]
<br /># force ssl for login page
<br />/simpleshirosecuredapplication/account/login.jsp=ssl[8443],authc
<br /># enable authc filter for the all application pages; as Shiro reads urls from up to down, must be last
<br />/simpleshirosecuredapplication/**=authc
<br /></PRE>
<br /></p>
<br /><H5>Configurar Usuários e Senhas</H5>
<br /><p>
<br />A aplicação SimpleShiroSecuredApplication estará agora disponível somente para usuários autenticados. Assim, é necessário adicionar alguns usuários de forma que algumas pessoas tenham acesso à aplicação.
<br />A configuração é feita na seção [users] do arquivo Shiro.ini. O formato das entradas da seção é:
<br /><PRE lang="vim">
<br />username = password, roleName1, roleName2, ..., roleNameN
<br /></PRE>
<br />A seguinte seção cria sete usuários, todos com a mesma senha 'heslo':
<br /><PRE lang="vim">
<br />[users]
<br />administrator=heslo,Administrator
<br />friendlyrepairmen=heslo,repairmen
<br />unfriendlyrepairmen=heslo,repairmen
<br />mathematician=heslo,scientist
<br />physicien=heslo,scientist
<br />productsales=heslo,sales
<br />servicessales=heslo,sales
<br /></PRE>
<br /></p>
<br /><p>
<br />Agora é possível ser autenticado e ter acesso à aplicação. No entanto, nenhuma mensagem de erro razoável é mostrada se o usuário comete um erro. Além disso, as senhas são armazenadas em arquivo texto.
<br /></p>
<br /><H5>Tratamento de Erro</H5>
<br /><p>
<br />Se o usuário comete um erro ao fazer a autenticação (log in), o Shiro o redireciona de volta para a página de login. A página parece exatamente a mesma de antes, o que pode confundir o usuário.
<br /></p>
<br /><B>Novo requerimento:</B> 
<br />Mostrar mensagem de erro após cada tentativa de autenticação(log in) sem êxito.
<br /></p>
<br /><p>
<br />Toda vez que ocorrer um erro de autenticação, uma exceção é lançada. Por definição, o filtro de autenticação captura a exceção e armazena nome da classe (exceção) em um parâmentro da requisição (request). Como desejamos personalizar os dados enviados à página, teremos que estender o filtro pré-definido <a href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/FormAuthenticationFilter.html" target="_blank">FormAuthenticationFilter</a> e sobrescrever o método <a href="https://github.com/SomMeri/SimpleShiroSecuredApplication/blob/static_authentication_and_authorization/src/main/java/org/meri/simpleshirosecuredapplication/servlet/VerboseFormAuthenticationFilter.java" target="_blank">setFailureAttribute</a>:
<br /></p>
<br /><PRE lang="java">
<br />@Override
<br />protected void setFailureAttribute(ServletRequest request, AuthenticationException ae) {
<br />  String message = ae.getMessage();
<br />  request.setAttribute(getFailureKeyAttribute(), message);
<br />}
<br /></PRE>
<br /><p>
<br />Substitua o filtro pré-definido FormAuthenticationFilter por <a href="https://github.com/SomMeri/SimpleShiroSecuredApplication/blob/static_authentication_and_authorization/src/main/java/org/meri/simpleshirosecuredapplication/servlet/VerboseFormAuthenticationFilter.java">VerboseFormAuthenticationFilter</a> e o configure para usar o atributo de requisição (request) 'simpleShiroApplicationLoginFailure' para armazenar a informação do erro:
<br /></p>
<br /><PRE lang="vim">
<br />[main]
<br /># replace form authentication filter with verbose filter
<br />authc = org.meri.simpleshirosecuredapplication.servlet.VerboseFormAuthenticationFilter
<br /># request parameter with login error information; if not present filter assumes 'shiroLoginFailure'
<br />authc.failureKeyAttribute=simpleShiroApplicationLoginFailure
<br /></PRE>
<br /><p>
<br />Mostrar o erro na página login.jsp:
<br /></p>
<br /><PRE lang="java">
<br /><%
<br />  String errorDescription = (String) request.getAttribute("simpleShiroApplicationLoginFailure");
<br />  if (errorDescription!=null) {
<br />%>
<br />Login attempt was unsuccessful: <%=errorDescription%>
<br /><%
<br />  }
<br />%>
<br /></PRE>
<br /><p>
<br />Cuidado: uma aplicação real não deve apresentar muitas informações de erro de autenticação. Uma mensagem como "tentativa de logon sem sucesso.", com nenhuma informação adicional é geralmente suficiente.
<br /></p>
<br /><H5>Hashing de Senhas</H5>
<br /><p>
<br />Na versão atual da aplicação, todas as senhas estão, ainda, em texto puro. É melhor armazenar e comparar somente o hashing da senha.
<br /></p>
<br /><p>
<br />Objetos responsáveis por autenticação são chamados de <A href="http://shiro.apache.org/realm.html" target="_blank"> realms</A>. Por padrão, Shiro usa o <A href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/realm/text/IniRealm.html" target="_blank"> IniRealm</A> com comparador de senha plugável para comparar senhas. Iremos substituir as senhas no ini por suas correspondentes hasheadas com SHA-256 e configurar o IniRealm para usar este comparador de senhas.
<br /></p>
<br /><p>
<br />Gerar o hash SHA-256 da senha:
<br /><PRE lang="java">
<br />import org.apache.shiro.crypto.hash.Sha256Hash;
<br />
<br />public static void main(String[] args) {
<br />    Sha256Hash sha256Hash = new Sha256Hash("heslo");
<br />    System.out.println(sha256Hash.toHex());
<br />}
<br /></PRE>
<br /></p>
<br /><p>
<br />Configurar o Shiro para comparar senha trasnformada(hashing) ao invés da própria senha:
<br /><PRE lang="vim">
<br />[main] 
<br /># define matcher matching hashes instead of passwords
<br />sha256Matcher = org.apache.shiro.authc.credential.HashedCredentialsMatcher
<br />sha256Matcher.hashAlgorithmName=SHA-256
<br />
<br /># enable matcher in iniRealm (object responsible for authentication)
<br />iniRealm.credentialsMatcher = $sha256Matcher
<br /></PRE>
<br /></p>
<br /><p>
<br />Substituir as senhas dos usuários por senhas trasnformadas(hashing):
<br /><PRE lang="vim">
<br />[users]
<br />administrator=56b1db8133d9eb398aabd376f07bf8ab5fc584ea0b8bd6a1770200cb613ca005, Administrator
<br />friendlyrepairmen=56b1db8133d9eb398aabd376f07bf8ab5fc584ea0b8bd6a1770200cb613ca005, repairmen
<br />unfriendlyrepairmen=56b1db8133d9eb398aabd376f07bf8ab5fc584ea0b8bd6a1770200cb613ca005, repairmen
<br />mathematician=56b1db8133d9eb398aabd376f07bf8ab5fc584ea0b8bd6a1770200cb613ca005, scientist
<br />physicien=56b1db8133d9eb398aabd376f07bf8ab5fc584ea0b8bd6a1770200cb613ca005,  scientist
<br />productsales=56b1db8133d9eb398aabd376f07bf8ab5fc584ea0b8bd6a1770200cb613ca005,        sales
<br />servicessales=56b1db8133d9eb398aabd376f07bf8ab5fc584ea0b8bd6a1770200cb613ca005,  sales
<br /></PRE>
<br />Nota: não é possível especificar SALT no arquivo de configuração ini.
<br /></p>
<br /><H5>Criar Página de Saída(Log out)</H5>
<br /><p>
<br />Qualque aplicação que tenha recursos de autenticação deveria também ter o recurso de saída. Terminar uma sessão corrente com Shiro é fácil, use o comando: 
<br /><PRE lang="java">
<br />//acquire currently logged user and log him out
<br />SecurityUtils.getSubject().logout();
<br /></PRE>
<br />A página de saída(Log out) então fica assim:
<br /><PRE lang="xml">
<br /><%@ page import="org.apache.shiro.SecurityUtils" %>
<br /><% SecurityUtils.getSubject().logout();%>
<br />You have succesfully logged out. 
<br /></PRE>
<br /></p>
<br /><H4>Adicionar Autorização</H4>
<br /><p>
<br />Concluiremos esta primeira parte adicionando autorização à aplicação. Começamos limitando o acesso às páginas aos usuários. Nenhum usuário deveria ser capaz de ver páginas de outros departamentos. Fornecendo assim, somente segurança parcial ao projeto, pois o usuário ainda é capaz de usar a página com "todas as funções da aplicação" ou editar o endereço (url) no navegador para realizar qualquer ação. Nós a chamaremos de autorização em nível de página.
<br /></p>
<br /><p>
<br />Então, limitaremos a habilidade dos usuários para realizar ações próprias. Mesmo que abra a página com "todas as funções da aplicação" ou edite o endereço (url) no navegador, ele poderá realizar somente funções específicas de seu departamento. Nós a chamaremos de autorização em nível de função.
<br /></p>
<br /><p>
<br /><B>Novos requisitos:</B> o usuário não é capaz de ver páginas de departamentos que não pertence. O usuário é capaz de realizar somente funções de seu departamento. Uma exceção a essa regra é o administrador, que pode realizar funções administrativas e de reparação.
<br /></p>
<br />
<br /><H5>Página de Autorização</H5>
<br /><p>
<br />Autorização em nível de página é feita com filtro de perfis(roles). 
<br />Parâmetro parte do filtro pode conter qualquer número de perfis. Usuário autenticado pode acessar a página somente se ele tem todas os perfis fornecidos.
<br /></p>
<br />Como de costume, o filtro de perfis(roles) é configurado no arquivo Shiro.ini: 
<br /><PRE lang="vim">
<br />[urls]
<br /># force ssl for login page
<br />/simpleshirosecuredapplication/account/login.jsp=ssl[8443],authc
<br />
<br /># only users with some roles are allowed to use role-specific pages 
<br />/simpleshirosecuredapplication/repairmen/**=authc, roles[repairman]
<br />/simpleshirosecuredapplication/sales/**=authc, roles[sales]
<br />/simpleshirosecuredapplication/scientists/**=authc, roles[scientist]
<br />/simpleshirosecuredapplication/adminarea/**=authc, roles[Administrator]
<br />
<br /># enable authc filter for the all application pages; as Shiro reads urls from up to down, must be last
<br />/simpleshirosecuredapplication/**=authc
<br /></PRE>
<br />Teste se a segurança funciona: entre como um usuário de vendas, clique home, clique no link 'repairmen page'. Você verá um erro feio.
<br /></p>
<br /><p>
<br />Nós terminamos a página de autorização e substituimos o erro redirecionando-o para uma página de erro. Os filtros pré-definidos do Shiro possuem a propriedade unauthorizedUrl. Em caso de acesso não autorizado, o filtro redirecionará o usuário para um endereço (url) específico.
<br /><PRE lang="vim">
<br />[main]
<br /># redirect to an error page if user does not have access rights
<br />roles.unauthorizedUrl = /simpleshirosecuredapplication/account/accessdenied.jsp
<br /></PRE>
<br /></p>
<br /><p>
<br />accessdenied.jsp:
<br /></p>
<br /><PRE lang="xml">
<br /><body>
<br />Sorry, you do not have access rights to that area.
<br /></body>
<br /></PRE>
<br /></p>
<br /><H5>Autorização de Funções</H5>
<br /><p>
<br />Todas as páginas departamentais estão protegidas agora. No entanto, qualquer usuário pode ainda realizar qualquer função na página com "todas as funções da aplicação". Além disso, qualquer usuário autenticado pode editar endereço (url) e assim fazer qualquer ação. Por exemplo, se você entrar como vendedor e colocar 
<br /> https://localhost:8443/simpleshirosecuredapplication/masterservlet?action=MANAGE_REPAIRMEN na  url, a aplicação irá realizar a função gerenciar reparadores também (e então irá dispará a exceção: null point, mas a violação de segurança já foi feita).
<br />Atribuimos uma úncia <A href="http://shiro.apache.org/permissions.html" target="_blank"> permissão</A> para cada função. Elas estão divididas em grupos:
<br /><UL>
<br /><LI>todas as permissões estão no grupo "functions",</LI>
<br /><LI>todas as permissões administrativas estão no grupo "manage",</LI>
<br /><LI>todas as permissões reparação estão no grupo "repair",</LI>
<br /><LI>todas as permissões venda estão no grupo  "sale", </LI>
<br /><LI>todas as permissões ciência estão no grupo "science".</LI>
<br /></UL>
<br /></p>
<br /><p>
<br />Shiro suporta permissões de múltiplos níveis representadas como strings. Níveis são separados com o símbolo ':'. p.e. "functions:manage:repairmen" tem três níveis: "functions", "manage" e "repairman". Permissões de múltiplos níveis permitem facilmente o agrupamento de permissões. Por exemplo, o grupo science pertence ao grupo functions e contém três permissões:
<br /><UL>
<br /><LI>functions:science:research,</LI>
<br /><LI>functions:science:writearticle,</LI>
<br /><LI>functions:science:preparetalk.</LI>
<br /></UL>
<br />A classe <A href="https://github.com/SomMeri/SimpleShiroSecuredApplication/blob/static_authentication_and_authorization/src/main/java/org/meri/simpleshirosecuredapplication/actions/Actions.java" target="_blank"> Ações</A> verifica as permissões do usuário autenticado(log in) antes de fazer seu trabalho:
<br /><PRE lang="java">
<br />public String doIt() {
<br />    String neededPermission = getNeededPermission();
<br />    // acquire logged user and check permission
<br />    if (SecurityUtils.getSubject().isPermitted(neededPermission))
<br />        return "Function " + getName() + " run succesfully.";
<br />
<br />    throw new UnauthorizedException("Logged user does not have " + neededPermission + " permission");
<br />}
<br /></PRE>
<br />NOTA: Outro modo de se alcançar o mesmo objetivo é através de anotações.
<br /></p>
<br /><p>
<br />O servlet <A href="https://github.com/SomMeri/SimpleShiroSecuredApplication/blob/static_authentication_and_authorization/src/main/java/org/meri/simpleshirosecuredapplication/servlet/PerformFunctionAndGoBackServlet.java" target="_blank"> PerformFunctionAndGoBackServlet</A> captura exceções de autorização e as converte em mensagem de erro: 
<br /><PRE lang="java">
<br />private String performAction(String actionName) {
<br />    try {
<br />        Actions action = findAction(actionName);
<br />        String result = action == null ? null : action.doIt();
<br />        log.debug("Performed function with result: " + result);
<br />        return result;
<br />    } catch (ShiroException ex) {
<br />        log.debug("Function failed with " + ex.getMessage() + " message.");
<br />        return "Error: " + ex.getMessage();
<br />    }
<br />}
<br /></PRE>
<br /></p>
<br /><p>
<br />Finalmente, precisamos configurar as permissões para os perfis no arquivo Shiro.ini.  Shiro suporta curingas para permissões de múltiplo nível. Assim, não temos que especificar cada permissão departamental em separado:
<br /><PRE lang="vim">
<br />[roles]
<br /># members of departments should be able to perform all departmental functions
<br />sales=functions:sale:*
<br />scientist=functions:science:*
<br />repairman=functions:repair:*
<br />
<br /># administrators are able to do all management functions and repair functions
<br />Administrator=functions:manage:*,functions:repair:*
<br /></PRE>
<br /></p>
<br /><p>
<br />Você pode agora acessar a página "todas as funções da aplicação" e testar as funções.  
<br />Se um usuário autenticado não tiver a permissão requerida, uma mensagem de erro aparecerá no topo da página. Além disso, se você fizer a autenticação (log in) como vendedor e tentar hackear
<br />  https://localhost:8443/simpleshirosecuredapplication/masterservlet?action=MANAGE_REPAIRMEN, você verá uma mensagem de erro no console (em vez de uma mensagem de sucesso).
<br /></p>
<br /><H4>Fim</H4>
<br /><p>
<br />A aplicação final está disponível no ramo(branch) <A href="https://github.com/SomMeri/SimpleShiroSecuredApplication/tree/static_authentication_and_authorization" target="_blank"> 'static_authentication_and_authorization'</A> hospedado no Github. 
<br /></p>
<br /><p>
<br />Na segunda parte iremos criar um <A href="http://shiro.apache.org/realm.html" target="_blank"> realm</A> personalizado e mover usuários, senhas, perfis(roles) e permissões do arquivo ini para um banco de dados.
<br /></p>
</p>
      <div class="share">
  <!-- Facebook -->
          <a href="http://www.facebook.com/sharer.php?u=http://blog.gilbertoca.com/2011/04/apache-shiro-parte-1-basico.html" target="_blank"><img src="/img/sharebuttons/facebook.png" alt="Facebook" /></a>
  <!-- Google+ -->
  <!-- Twitter -->
          <a href="http://twitter.com/share?url=http://blog.gilbertoca.com/2011/04/apache-shiro-parte-1-basico.html&text=Apache Shiro Parte 1 - básico blog.gilbertoca.com/2011/04/apache-shiro-parte-1-basico.html" target="_blank"><img src="/img/sharebuttons/twitter.png" alt="Twitter" /></a>
      </div>
            </article>
        </div> <!-- /.col-md-12 -->
      </div> <!-- /.row -->
        
      </div><!-- /.container -->

    <footer>
      <div class="container">
        <hr>
        <div class="row">
          <div class="col-xs-10">
            <p class="text-muted credit">&copy; Gilberto Caetano de Andrade 2014 | Mixed with <a href="http://getbootstrap.com/">Bootstrap v3.1.1</a> | Baked with <a href="http://jbake.org">JBake v2.2.1</a> | <i title="Linux" class="fa fa-linux"></i></p>
          </div>
          <div class="col-xs-2 gotop">
            <a href="#"><i class="fa fa-arrow-circle-up"> top</i></a>
          </div>
        </div>
      </div>
    </footer>

    <!-- Placed at the end of the document so the pages load faster -->
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <script src="//netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/gist-embed/1.6/gist-embed.min.js"></script>
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
    <script type="text/javascript">
      <!-- load prettify only when needed -->
      $(document).ready(function(){
        var prettify = false;
        var classToAdd = 'prettyprint snippet';
        $("pre > code").each(function() {
          $("pre > code").parent().addClass(classToAdd);
          prettify = true;
        });
        if(prettify) {
          prettyPrint();
        }
      });
    </script>


        </body>
</html>
